[{"title":"personalSite","date":"2017-04-13T06:49:56.000Z","path":"2017/04/13/personalSite/","text":"禅道：http://www.laomao.party/zentaopms/www/index.php?","tags":[]},{"title":"SimpleMvp","date":"2017-03-16T06:20:04.000Z","path":"2017/03/16/SimpleMvp/","text":"本文是对自己使用的项目SimpleMvp的讲解，项目源码见github(https://github.com/Mao-x-w/SimpleMvp), 该项目是在git大神的android10的项目Android-CleanArchitecture基础上进行的更改，有兴趣的可以直接看该大神的源码：（https://github.com/android10/Android-CleanArchitecture） 本文主要讲解如何使用该Mvp框架，对于运用的Dagger2,Rxjava,Retrofit,Lamada技术不做讲解，不了解的哥们可以先自己学习一下。这里推荐一些学习资料： Dagger2 使用详解：http://www.jianshu.com/p/94d47da32656 给 Android 开发者的 RxJava 详解：https://gank.io/post/560e15be2dca930e00da1083 RxJava+Retrofit+OkHttp深入浅出：http://blog.csdn.net/wzgiceman/article/details/51939574 mvp介绍Domain层作为Presenter和Data层的桥梁，定义Repository接口，由Data层实现。定义UseCase类，从Repository接口获取数据，也就是从其实现类Data层获取数据。 Data层依赖于Domain层，直接从服务器获取需要的数据，并通过实现Domain层的接口，将数据传递到Domain层中。 Presenter层依赖于Domain层，通过使用Dagger2的依赖注入技术，将Domain层的UseCase注入到Presenter中，同时定义接口，用于向UI层返回数据。 UI层依赖于Presenter层，将Presenter通过依赖注入方式注入到需要请求网络的地方（如：Activity，Adapter,Fragment等等），并实现Presenter层中定义的接口，以便拿到数据 mvp模式好处 分离了视图逻辑和业务逻辑，降低了耦合，可以将业务逻辑写在Domain层中，而视图逻辑可以写到Presenter层中，对于UI层，只用于展示数据 简化了UI层的代码，原来一个Activity很容易就上千行代码。使用MVP之后，Activity大大的瘦身了。 提供了代码的可读性，方便后期维护 撸代码介绍了这么多，现在来看看具体在项目中的应用。在本项目中对代码做了高度封装，就不介绍封装方式了，有兴趣可以自己研究，主要介绍如何使用本项目完成一次网络请求。 项目结构 其中app对应为UI层，app_common层相当于一个工具类层，将所有层等能用到的放到了这一层，可以忽略不管这个。而app_domain,app_data,app_presenter分别为domain层，data层，presenter层 domain层代码 首先定义IGeneralRepository接口： 12345public interface IGeneralRepository extends IRepository &#123; Observable&lt;List&lt;GitUserModel&gt;&gt; getGitUsers();&#125; 该接口主要目的是衔接Data层和Domain层，Data层有特定类实现类了该接口，从而调用该接口中的方法能返回Data层数据，详细讲解在Data层。 IGeneralRepository接口衔接了Data层，而和Presenter层的交互是通过UseCase进行的： 1234567891011121314151617181920@Singletonpublic class GitUsersUseCase extends UseCaseImpl&lt;IGeneralRepository,Object,List&lt;GitUserModel&gt;&gt; &#123; /** * 构造参数 * * @param repository * @param workThread 工作线程 * @param resultThread 结果执行线程 */ @Inject public GitUsersUseCase(IGeneralRepository repository, ThreadExecutor workThread, PostExecutionThread resultThread) &#123; super(repository, workThread, resultThread); &#125; @Override protected Observable&lt;List&lt;GitUserModel&gt;&gt; buildUseCaseObservable(Object... objects) &#123; return getRepository().getGitUsers(); &#125;&#125; 在该类中通过getRepository().getGitUsers()获取到了IGeneralRepository的实现类中返回的数据，那么只要Presenter层拿到该UseCase对象，就相当于和Domain层建立了连接，而Presenter是依赖Doamin层，所以拿到对象很容易，不过我们这里使用的是Dagger2依赖注入拿到的UseCase对象，关于Dagger2的使用这里不做介绍。以后有时间单讲。 Domain层不仅连接了Data层和Presenter层，同时，它也起到了一个约束的作用，所有请求和Data有关的代码都是这样做，这时，即使不写代码注释，思路依然很清闲，扩展性很强。 data层代码由于data层的数据来源很多，服务器、本地Json、数据库、内存等，这里我单独总结了一下，见个人博客：http://laomao.space/2017/03/15/SimpleMvp-Data/ presenter层代码 通过dagger2得到Domain层中的UseCase对象。12345678910@Modulepublic class GeneralModule &#123; @Provides @Named(Constants.NAMED_GIT_USERS) UseCase&lt;Object,List&lt;GitUserModel&gt;&gt; provideGitUsersUseCase(IGeneralRepository repository, ThreadExecutor executor, PostExecutionThread thread)&#123; return new GitUsersUseCase(repository,executor,thread); &#125;&#125; 接着定义一个接口IGitUsersView用于连接UI层和Presenter层 12345public interface IGitUsersView extends ILoadingView&#123; void onGetGitUsers(List&lt;GitUser&gt; users);&#125; 这个时候只需要一个中间者，将从UseCase中获取到的数据，传递给接口中的onGetGitUsers(List users)，那么实现了该接口的UI层就能拿到了数据，这个中间者就是Presenter 1234567891011121314151617181920212223public class GitUsersPresenter extends LoadingPresenter&lt;Object,Object,List&lt;GitUserModel&gt;,List&lt;GitUser&gt;,IGitUsersView&gt; &#123; private GitUserMapper mGMapper; @Inject public GitUsersPresenter( @Named(Constants.NAMED_GIT_USERS) @NonNull UseCase&lt;Object, List&lt;GitUserModel&gt;&gt; useCase, GitUserMapper gMapper) &#123; super(useCase); mGMapper = gMapper; &#125; @Override public void initialize(Object... objects) &#123; execute(objects); &#125; @Override public void onNext(List&lt;GitUserModel&gt; gitUserModels) &#123; super.onNext(gitUserModels); getView().onGetGitUsers(mGMapper.transform(gitUserModels)); &#125;&#125; 可以看到在onNext方法中，返回了数据，具体怎么返回在GitUsersPresenter的父类中封装的呢，有兴趣自己研究，通过getView拿到IGitUsersView接口对象，并把数据传递给onGetGitUsers()方法。 UI层代码 首先使用@Component注解一个连接器GeneralComponent12345@PerActivity@Component(dependencies = ApplicationComponent.class,modules = &#123;ActivityModule.class, GeneralModule.class&#125;)public interface GeneralComponent extends ActivityComponent&#123; void inject(GitUsersActivity activity);&#125; 它的作用是让那些想要使用Dagger2依赖注入的地方提供一个通道，而那些要使用地方来这里登记一下void inject(GitUsersActivity activity);因为我们在GitUsersActivity中要使用Presenter，所以这里将这个Activity登记一下。123456789101112131415161718192021222324252627public class GitUsersActivity extends BaseActivity implements IGitUsersView &#123; @Inject GitUsersPresenter mPresenter; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_git_users); // 初始化网络请求 DaggerGeneralComponent.builder().applicationComponent(getApplicationComponent()).activityModule(getActivityModule()).build().inject(this); mPresenter.setView(this); // 发起网络请求 mPresenter.initialize(); &#125; /** * 网络请求返回数据 * @param users */ @Override public void onGetGitUsers(List&lt;GitUser&gt; users) &#123; // 处理网络返回数据 &#125;&#125; 这里把GitUsersPresenter注入到了GitUsersActivity中，虽然注入了，但GitUsersActivity不知道去哪里找，所以需要将GitUsersActivity在GeneralComponent中登记一下，DaggerGeneralComponent.builder().applicationComponent(getApplicationComponent()).activityModule(getActivityModule()).build().inject(this);这个时候就可以使用Presenter实例了，使用mPresenter.setView(this)给Presenter设置View对象，这里用this是因为activity实现了Presenter层的接口IGitUserView，这样Presenter层就能拿到接口的实例对象，从而给UI层返回数据。最后通过mPresenter.initialize()发起网络请求，当然如果有参数可以在initialize()方法中添加。最后数据就通过实现了IGitUserView接口的onGetGitUsers(List users)方法返回。 至此，就成功的完成了一次网络请求。刚开始学习使用MVP,是很痛苦的，莫名其妙的加大了好多工作量，但是，如果你能坚持下来，你会发现后期维护起来非常容易。 自从使用了MVP，妈妈再也不用担心我打产品经理了。 哈哈哈哈哈。。。。。。 文笔太差，有不足地方请指正","tags":[]},{"title":"SimpleMvp_Data","date":"2017-03-15T08:54:52.000Z","path":"2017/03/15/SimpleMvp-Data/","text":"本文是对自己使用的项目SimpleMvp的Data层讲解，项目源码见github(https://github.com/Mao-x-w/SimpleMvp), 该项目是在git大神的android10的项目Android-CleanArchitecture基础上进行的更改，有兴趣的可以直接看该大神的源码：（https://github.com/android10/Android-CleanArchitecture） 首先说一下自己对继承、实现的体会，这些只是我自己为了加深记忆写的，对于我来说很有用，因为，我感觉人的大脑就像一个巨大的Map库，当我们看到一些东西的时候，实际对于大脑而言只是一个key,大脑会拿这个key去找对应的value，而下面这些体会，可以说就是对我之前踩的一些坑的key，看到这些描述，我就能想到当时是怎么出错的，走的那些弯路。当然，可能对大伙用处不大，感觉无用的请自动略过。直接看SimpleMvp的Data层讲解 继承、实现的体会 定义一个接口之后，可以有多个类去实现它，那么最后当你用的时候就可以根据你调用哪一个，从而确定出你使用的对象，接口是不能直接创建对象的，所以，你最终使用的肯定是某个具体的实现。那么，无论有多少个类实现了这个接口都是没有关系的，最终使用的时候，看你调用的是哪一个。 例如：List list=new ArrayList();而不能List list=new List();除非自己去实现List，就可以这样写： List list=new List{……} 所以，要时刻保持清醒，调用了一个接口，本质上是调用了他的一个实现类，具体是哪一个，代码中找 继承，可以在共有的功能基础上扩展出来新功能。这样的好处是各个地方使用的是自己的继承过来的扩展类，当有多个地方使用这个类的时候，不同的功能都通过调用自己的类，而不去基类中找，就不会污染基类，增强了基类的扩展型，以及使用型。 SimpleMvp中Data层中的具体实现 Data层与Domain层对接是通过实现Domain层的接口，而domain层直接调用接口中的方法，就相当于拿到了Data层返回的数据，下面着重讲Data层。大家看的时候尽量对照着源码，这样学习比较省力，当然代码我也贴了出来。 12345678910111213141516@Singletonpublic class GeneralRepositoryImpl extends RepositoryImpl&lt;IGeneralDataStore, GeneralDataStoreFactory&gt; implements IGeneralRepository &#123; private GitUserEntityMapper mGMapper; @Inject public GeneralRepositoryImpl(GeneralDataStoreFactory dataStoreFactory, GitUserEntityMapper gMapper) &#123; super(dataStoreFactory); mGMapper = gMapper; &#125; @Override public Observable&lt;List&lt;GitUserModel&gt;&gt; getGitUsers() &#123; return getNetDataStore().getGitUsers().map(mGMapper::transformTo); &#125;&#125; GeneralRepositoryImpl实现了IGeneralRepository接口，从而实现了其中的getGitUsers方法，而在该方法中调用getNetDataStore().getGitUsers()是调用 12345public interface IGeneralDataStore extends IDataStore &#123; Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers();&#125; IGeneralDataStore接口中的方法（本质是调用某个具体实现类中的方法），而getNetDataStore()获取到的是该接口的一个具体实现类NetGeneralDataStore。 12345678910111213@Singletonpublic class NetGeneralDataStore extends NetDataStoreImpl&lt;IGeneralNet,IGeneralCache&gt; implements IGeneralDataStore &#123; @Inject public NetGeneralDataStore(IGeneralNet service, IGeneralCache cache) &#123; super(service, cache); &#125; @Override public Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers() &#123; return getService().getGitUsers(); &#125;&#125; 具体为什么是调用的这个实现类而不是其他实现类，这个在GeneralRepositoryImpl的父类RepositoryImpl中定义的，有兴趣可以自己研究一下，就不描述了。 现在我们再来整理一下头绪，我们想从Data层获取数据，首先调用IGeneralRepository的具体实现GeneralRepositoryImpl中的getGitUsers()方法，然后该方法又去调用IGeneralDataStore的具体实现NetGeneralDataStore中的getGitUsers()方法。（具体为什么要这样写，而不是直接调用访问网络接口，把数据直接传递给上层，最后会加以描述） 现在我们就可以把注意力放到NetGeneralDataStore类上了，我们可以看到它是通过getService().getGitUsers()来返回需要的数据，按住ctrl键+鼠标左键点击getGitUsers()方法，发现又跳回了上面的那个接口IGeneralDataStore中，这是什么情况？自己本身就实现IGeneralDataStore接口中的方法，而这个方法又调用了这个接口的方法，不会递归 么？？？ 答案是不会的：关键是getService()方法。 通过研究代码发现getService得到的是IGeneralDataStore接口的另一个实现类（感兴趣的自己研究）GeneralRetrofitNetImpl 1234567891011public class GeneralRetrofitNetImpl extends BaseRetrofitNetImpl&lt;IGeneralRetrofit&gt; implements IGeneralNet &#123; @Inject public GeneralRetrofitNetImpl() &#123; &#125; @Override public Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers() &#123; return getService().getGitUsers(); &#125;&#125; 对于这里的理解，本文的最开头的一些体会就起到了作用，应该很好理解吧，哈哈。我当时是想了好久好久才想明白的，大家应该比我牛逼，很快就理解了吧，不理解的可以再看一下开头的一些体会。 好了，现在我们定位到了GeneralRetrofitNetImpl类中了，可以看到它里面也有getService().getGitUsers()，同理，点击ctrl键+鼠标左键点击getGitUsers()方法，定位到了IGeneralRetrofit接口 123456public interface IGeneralRetrofit &#123; @GET(Constant.HttpHost.GIT_GOD_USERS) Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers();&#125; 这里我们终于来到了调用终点，当然终点也可能是另一个起点，那就是这个接口怎么就能请求服务器数据了，这就涉及到了Retrofit网络框架了，相信大家这块应该都会吧，不会哥们自己去研究下吧。 下面通过一张图来加深一下理解： 最后，我们就来看一下为什么要这样设计，而不是直接那服务器数据返回给上一层？ 这当然是为了解耦，加强扩展型，试想一下，假如我们某一天感觉Retrofit网络框架不好用了，要换框架了，那么我们只需要在GeneralRetrofitNetImpl和IGeneralRetrofit处做调整，按原来格式把数据返回就行，其他地方什么都不用动。又假如，产品来了，说这块数据是死的、而且数据量大，请求网络时间太长，要把json数据放到本地，那么我们只需要在GeneralRepositoryImpl类中getNetDataStore().getGitUsers()改为getLocalDataStore.getGitUsers（从本地取），或者getCacheDataStore.getGitUsers(从缓存取)，再或者getDBDateStore.getGitUsers(从数据库取)。是不是很灵活啊，实际中灵活的地方还有很多，就不一一举例了，自己体会吧。","tags":[]}]