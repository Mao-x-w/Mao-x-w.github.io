[{"title":"SimpleMvp_Data","date":"2017-03-15T08:54:52.000Z","path":"2017/03/15/SimpleMvp-Data/","text":"本文是对自己使用的项目SimpleMvp的Data层讲解，项目源码见github(https://github.com/Mao-x-w/SimpleMvp), 该项目是在git大神的android10的项目Android-CleanArchitecture基础上进行的更改，有兴趣的可以直接看该大神的源码：（https://github.com/android10/Android-CleanArchitecture） 首先说一下自己对继承、实现的体会，这些只是我自己为了加深记忆写的，对于我来说很有用，因为，我感觉人的大脑就像一个巨大的Map库，当我们看到一些东西的时候，实际对于大脑而言只是一个key,大脑会拿这个key去找对应的value，而下面这些体会，可以说就是对我之前踩的一些坑的key，看到这些描述，我就能想到当时是怎么出错的，走的那些弯路。当然，可能对大伙用处不大，感觉无用的请自动略过。直接看SimpleMvp的Data层讲解 继承、实现的体会 定义一个接口之后，可以有多个类去实现它，那么最后当你用的时候就可以根据你调用哪一个，从而确定出你使用的对象，接口是不能直接创建对象的，所以，你最终使用的肯定是某个具体的实现。那么，无论有多少个类实现了这个接口都是没有关系的，最终使用的时候，看你调用的是哪一个。 例如：List list=new ArrayList();而不能List list=new List();除非自己去实现List，就可以这样写： List list=new List{……} 所以，要时刻保持清醒，调用了一个接口，本质上是调用了他的一个实现类，具体是哪一个，代码中找 继承，可以在共有的功能基础上扩展出来新功能。这样的好处是各个地方使用的是自己的继承过来的扩展类，当有多个地方使用这个类的时候，不同的功能都通过调用自己的类，而不去基类中找，就不会污染基类，增强了基类的扩展型，以及使用型。 SimpleMvp中Data层中的具体实现Data层与Domain层对接是通过实现Domain层的接口，而domain层直接调用接口中的方法，就相当于拿到了Data层返回的数据，下面着重讲Data层。大家看的时候尽量对照着源码，这样学习比较省力，当然代码我也贴了出来。 12345678910111213141516@Singletonpublic class GeneralRepositoryImpl extends RepositoryImpl&lt;IGeneralDataStore, GeneralDataStoreFactory&gt; implements IGeneralRepository &#123; private GitUserEntityMapper mGMapper; @Inject public GeneralRepositoryImpl(GeneralDataStoreFactory dataStoreFactory, GitUserEntityMapper gMapper) &#123; super(dataStoreFactory); mGMapper = gMapper; &#125; @Override public Observable&lt;List&lt;GitUserModel&gt;&gt; getGitUsers() &#123; return getNetDataStore().getGitUsers().map(mGMapper::transformTo); &#125;&#125; GeneralRepositoryImpl实现了IGeneralRepository接口，从而实现了其中的getGitUsers方法，而在该方法中调用getNetDataStore().getGitUsers()是调用 12345public interface IGeneralDataStore extends IDataStore &#123; Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers();&#125; IGeneralDataStore接口中的方法（本质是调用某个具体实现类中的方法），而getNetDataStore()获取到的是该接口的一个具体实现类NetGeneralDataStore。 12345678910111213@Singletonpublic class NetGeneralDataStore extends NetDataStoreImpl&lt;IGeneralNet,IGeneralCache&gt; implements IGeneralDataStore &#123; @Inject public NetGeneralDataStore(IGeneralNet service, IGeneralCache cache) &#123; super(service, cache); &#125; @Override public Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers() &#123; return getService().getGitUsers(); &#125;&#125; 具体为什么是调用的这个实现类而不是其他实现类，这个在GeneralRepositoryImpl的父类RepositoryImpl中定义的，有兴趣可以自己研究一下，就不描述了。 现在我们再来整理一下头绪，我们想从Data层获取数据，首先调用IGeneralRepository的具体实现GeneralRepositoryImpl中的getGitUsers()方法，然后该方法又去调用IGeneralDataStore的具体实现NetGeneralDataStore中的getGitUsers()方法。（具体为什么要这样写，而不是直接调用访问网络接口，把数据直接传递给上层，最后会加以描述） 现在我们就可以把注意力放到NetGeneralDataStore类上了，我们可以看到它是通过getService().getGitUsers()来返回需要的数据，按住ctrl键+鼠标左键点击getGitUsers()方法，发现又跳回了上面的那个接口IGeneralDataStore中，这是什么情况？自己本身就实现IGeneralDataStore接口中的方法，而这个方法又调用了这个接口的方法，不会递归 么？？？ 答案是不会的：关键是getService()方法。 通过研究代码发现getService得到的是IGeneralDataStore接口的另一个实现类（感兴趣的自己研究）GeneralRetrofitNetImpl 1234567891011public class GeneralRetrofitNetImpl extends BaseRetrofitNetImpl&lt;IGeneralRetrofit&gt; implements IGeneralNet &#123; @Inject public GeneralRetrofitNetImpl() &#123; &#125; @Override public Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers() &#123; return getService().getGitUsers(); &#125;&#125; 对于这里的理解，本文的最开头的一些体会就起到了作用，应该很好理解吧，哈哈。我当时是想了好久好久才想明白的，大家应该比我牛逼，很快就理解了吧，不理解的可以再看一下开头的一些体会。 好了，现在我们定位到了GeneralRetrofitNetImpl类中了，可以看到它里面也有getService().getGitUsers()，同理，点击ctrl键+鼠标左键点击getGitUsers()方法，定位到了IGeneralRetrofit接口 123456public interface IGeneralRetrofit &#123; @GET(Constant.HttpHost.GIT_GOD_USERS) Observable&lt;List&lt;GitUserEntity&gt;&gt; getGitUsers();&#125; 这里我们终于来到了调用终点，当然终点也可能是另一个起点，那就是这个接口怎么就能请求服务器数据了，这就涉及到了Retrofit网络框架了，相信大家这块应该都会吧，不会哥们自己去研究下吧。 下面通过一张图来加深一下理解： 最后，我们就来看一下为什么要这样设计，而不是直接那服务器数据返回给上一层？ 这当然是为了解耦，加强扩展型，试想一下，假如我们某一天感觉Retrofit网络框架不好用了，要换框架了，那么我们只需要在GeneralRetrofitNetImpl和IGeneralRetrofit处做调整，按原来格式把数据返回就行，其他地方什么都不用动。又假如，产品来了，说这块数据是死的、而且数据量大，请求网络时间太长，要把json数据放到本地，那么我们只需要在GeneralRepositoryImpl类中getNetDataStore().getGitUsers()改为getLocalDataStore.getGitUsers（从本地取），或者getCacheDataStore.getGitUsers(从缓存取)，再或者getDBDateStore.getGitUsers(从数据库取)。是不是很灵活啊，实际中灵活的地方还有很多，就不一一举例了，自己体会吧。","tags":[]},{"title":"Hello World","date":"2017-03-07T09:07:08.724Z","path":"2017/03/07/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]